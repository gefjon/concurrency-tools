(uiop:define-package :concurrency-tools/once-cell
  (:use :cl)
  (:export #:once-cell #:make-once-cell #:once-cell-get #:once))
(in-package :concurrency-tools/once-cell)

(deftype thunk ()
  '(function () (values t &optional)))

(eval-when (:compile-toplevel :load-toplevel)
  (defstruct unbound))
(declaim (type unbound +unbound+))
(sb-ext:defglobal +unbound+ (make-unbound))

(defstruct (once-cell (:constructor make-once-cell (thunk))
             (:conc-name %once-cell-))
  (value +unbound+)
  (thunk (error "must supply a thunk")
   :type (or thunk unbound))
  (lock (sb-thread:make-mutex)
   :type sb-thread:mutex
   :read-only t)
  (condvar (sb-thread:make-waitqueue)
   :type sb-thread:waitqueue
   :read-only t))

(declaim (ftype (function (once-cell) (values t &optional))
                once-cell-get))
(defun once-cell-get (once-cell)
  (with-accessors ((lock %once-cell-lock)
                   (condvar %once-cell-condvar)
                   (value %once-cell-value)
                   (thunk %once-cell-thunk))
      once-cell
    (sb-thread:with-mutex (lock)
      (labels ((finishedp ()
                 (not (eq value +unbound+)))
               (startedp ()
                 (eq thunk +unbound+))
               (steal-thunk ()
                 (shiftf thunk +unbound+))
               (make-finished (computed-val)
                 (prog1 (setf value computed-val)
                   (sb-thread:condition-broadcast condvar)))
               (compute-value ()
                 (let* ((thunk (steal-thunk)))
                   (make-finished (funcall thunk))))
               (wait ()
                 (sb-thread:condition-wait condvar lock)
                 (if (finishedp)
                     value
                     (wait))))
        (cond ((finishedp) value)
              ((startedp) (wait))
              (t (compute-value)))))))

(defmacro once-cell (&body body)
  `(make-once-cell (lambda () ,@body)))

(defmacro once (&body body)
  `(once-cell-get (load-time-value (once-cell ,@body))))
